require 'asciidoctor'

# Chunks the HTML output generated by the HTML5 converter by chapter.
#
# Usage
#
#   asciidoctor -r ./multipage-html5-converter.rb -b multipage_html5 book.adoc
#
class MultipageHtml5Converter
  include Asciidoctor::Converter
  include Asciidoctor::Writer

  register_for 'multipage'
  EOL = "\n".freeze

  def initialize(backend, opts)
    super
    basebackend 'html'
    @documents = []
  end

  def convert(node, transform = nil)
    transform ||= node.node_name
    send transform, node if respond_to? transform
  end

  def document(node)
    indexconfigs = {
      'stylesheet' => 'styles/main.css',
      'find' => '',
      'docinfodir' => 'headers',
      'docinfo1' => 'true'
    }
    node.blocks.each(&:convert)
    node.blocks.clear
    master_content = []
    master_content << %(= #{node.doctitle})
    master_content << (node.attr 'author') if node.attr? 'author'
    master_content << ''
    # @documents.each do |doc|
    #   sect = doc.blocks[0]
    #   sectnum = sect.numbered && !sect.caption ? %(#{sect.sectnum} ) : nil
    #   filename = doc.attr 'docname'
    #   filename = filename.sub(/^_/, '')
    #   master_content << %(== <<#{filename}#,#{sectnum}#{sect.captioned_title}>> +)
    # end
    master_content << ''
    master_content << 'requirements::[]'
    Asciidoctor.convert master_content, doctype: node.doctype, header_footer: true, safe: node.safe, attributes: indexconfigs
  end

  def section(node)
    doc = node.document
    node.id.gsub!(/_2$/, '') if node.id[/_2$/]
    configs = doc.attributes.clone
    configs['noheader'] = ''
    configs['doctitle'] = node.title
    configs['backend'] = 'html'
    page = Asciidoctor::Document.new [], header_footer: true, doctype: doc.doctype, safe: doc.safe, parse: true, attributes: configs

    page.set_attr 'docname', node.id
    reparent node, page

    page.blocks << node
    @documents << page
    ''
  end

  def reparent(node, parent)
    node.parent = parent
    node.blocks.each do |block|
      reparent block, node unless block.context == :dlist
      if block.context == :table
        block.columns.each do |col|
          col.parent = col.parent
        end
        block.rows.body.each do |row|
          row.each do |cell|
            cell.parent = cell.parent
          end
        end
      elsif block.context == :dlist
        block.parent = parent
        block.items.each do |i|
          reparent i[1], parent if i[1].respond_to? 'parent'
        end
      end
    end
  end

  def write(output, target)
    outdir = ::File.dirname target
    puts '[CHUNKED HTML] Generating chapters:'
    @documents.each do |doc|
      filename = doc.attr 'docname'
      filename = filename.sub(/^_/, '')
      outfile = ::File.join outdir, %(#{filename}.html)
      puts "[CHAPTER] #{outfile}"
      ::File.open(outfile, 'w') do |f|
        f.write doc.convert
      end
    end
    chunked_target = target.gsub(/(\.[^.]+)$/, '-chunked\1')
    puts "[HTML INDEX] Generating index at #{chunked_target}"
    ::File.open(chunked_target, 'w') do |f|
      f.write output
    end
  end
end
